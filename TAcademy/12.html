<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
   <HEAD>
      <TITLE>My first HTML document</TITLE>
     <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js" type="text/javascript">    
    MathJax.Hub.Config({
        HTML: ["input/TeX","output/HTML-CSS"],
        TeX: { extensions: ["AMSmath.js","AMSsymbols.js"], 
               equationNumbers: { autoNumber: "AMS" } },
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: { inlineMath: [ ['$','$'], ["<br/>(","<br/>)"] ],
                   displayMath: [ ['$$','$$'], ["<br/>[","<br/>]"] ],
                   processEscapes: true },
        "HTML-CSS": { availableFonts: ["TeX"],
                      linebreaks: { automatic: true } }
    });
</script>
   </HEAD>
   <BODY>


<br/>@
12. Example applications with an applied deep learning

<br/>@
기존 통계 번역의문제점.<br/>
모든 정렬 정보를 가지고 있어야 하기 때문에 과도한 메모리를 사용한다.<br/>
처음 정렬 정보에 따라 번역이 달라진다.<br/>
단어/구문 번역 모델은 의미가 비슷한 단어나 구문을 고려하지 않고, 표면적인 동시 등장 횟수만 고려한다.<br/>

RNN은 문장 X가 나타날 확률 P(X)을 계산해 줬었는데, X를 단어들의 시계열 데이터로 보았었다. 그래서 문장 X가 나타날 확률을 각각의 단어들이 나타날 확률을 joint probability 로 계산을 했다. 이 joint probability 를 다시 conditional probability 로 나타냈다. <br/>

예를들어 나는 학교에 간다 라는 문장 X가 나타날 확률 P(X)는 P(X)=P(간다|나는, 학교에)*P(학교에|나는)*P(나는) 가 된다. <br/>

그런데 RNN은 이러한 conditional probability 를 매 시점 마다 계산 할 수 있었다.<br/>
$p(x_{t}|x_{until\;t)})=g(h_{t-1})$<br/>
그리고 이 conditional probability 를 계산하기 위해서 조건(context)이 필요한데 이러한 context 를 기반으로 알맞은 단어가 생성되었었다. <br/>

RNN은 이러한 context 정보를 은닉층에 저장했기때문에 은닉층을 컨텍스트층, 히스토리층 이라고 불리기도 한다. <br/>

<br/>@
두개의 신경망을 이용한 기계번역<br/>
두개의 RNN 이 문장 X가 주어졌을 때, Y가 나타날 확률을 모델링한다.
즉, 번역을 하기 위해서는 어떤 확률을 계산해야되냐면 다음과 같은 확률이다.<br/>
$P(y_{1}, y_{2}, ..., y_{T}|x_{1}, x_{2}, ..., x_{T})$<br/>
x들은 입력문장(원본문장)이다. y들은 번역된 문장이다.<br/>
입력문장이 주어졌을때 여기에 알맞은 번역된 문장이 뭔지 알아맞추는 문제이다. 원본문장이 주어졌을때 확률이 가장 높은 번역문장을 출력을 해야되는것이 번역문제라고 볼수 있다. <br/>

예를들면, 나는 학교에 간다 라는 문장을 영어로 번역한다면, I am going to the school. 이 문장이 가장 확률이 높아야한다. 그러기 위해서는 $P(y_{1}, y_{2}, ..., y_{T}|x_{1}, x_{2}, ..., x_{T})$ 이 계산을 두개의 RNN 이 계산할 수 있는 것이다. <br/>

그래서 원본문장을 인코딩 해주는 RNN을 인코더 RNN이라고 부른다. <br/>
각각의 단어들을 RNN의 은닉층에 있는 은닉벡터 h에 컨텍스트(히스토리)정보를 저장하는 것이다. $h_{t}=\phi_{\theta}(h_{t-1},x_{i})$<br/>
저장되어있는 이 은닉벡터 $h_{Ta}$는 전체 입력 문장의 정보를 종합적으로 담고 있는데 이 벡터를 디코더 RNN 에 전달한다.<br/>

그러면 디코더 RNN은 인코더 RNN이 전달한 은닉벡터를 바탕으로 해서 알맞은 단어를 생성하는 것이다. <br/>
똑같이 RNN의 식을 사용해서 단어를 생성해내는데 입력문장이 생성한 종합적인 입력정보, $y_{t-1}$ 디코더 RNN 이전 시점 단계까지 생성한 단어, $Z_{t-1}$ 디코더 RNN 의 은닉 유닉정보 를 포함하고 있다. 왜 포함하냐면 I am going to the school 이라는 번역 문장을 출력해야되는데 내가 번역을 할때 이전 단어만 필요한게 아니라 이전의 컨텍스트 정보도 필요하다. 이러한 인코더 RNN으로부터 출력된 문장의 컨텍스트 정보를 담고있는게 디코더 RNN의 은닉 유닛이다. <br/>

인코더 RNN, 디코더 RNN 이 어떻게 기계번역을 하는지 그림으로 보자.<br/>
먼저 인코더 RNN이 있다. 입력 문장이 들어오면 각각의 시계열 데이터 단어를 매 시점마다 입력으로 받는다. 그러면 은닉 유닛은 벡터는 매번 들어오는 각각의 단어들을 인코딩한다. 입력 문장을 모두 받았으면 인코더 RNN 의 은닉유닉 벡터는 입력문장의 정보를 모두 포함하고 있을 것이다. <br/>
이 식 $h_{t}=f(U_{e}x_{t}+W_{e}h_{t-1})$ 은 RNN 의 은닉 유닉 벡터를 계산하는데 사용되는 식이다. <br/>
그럼 최종적으로 계산된 은닉유닉벡터 $h_{Ta}$ 가 있을 것이다. <br/>

디코더 RNN 은 매 시점마다 $h_{Ta}$ 와 이전 시간까지 생성한 단어 정보를 기반으로 새로운 단어를 생성한다.
$z_{t}=f(U_{d}y_{t-1}+W_{d}z_{t-1}+Ch_{Ta})$ <br/>
$y_{t-1}=softmax(Vz_{t})$<br/>

이 벡터 $h_{Ta}$ 를 디코더 RNN 에 매번 은닉 유닛 벡터를 계산할 때마다 가중치 C를 곱하면서 넣어준다. 그러면 이 디코더 RNN 은 은닉유닛 벡터를 계산 해 줄텐데 이 은닉 유닛 벡터는 이전시간에 디코더 RNN이 생성했던 단어들의 정보와 함께 새로운 단어를 생성한다.<br/>

디코더 재현 신경망을 조금더 자세히 살펴 보면, 다음과 같은 모습을 가지고 있다.<br/>
df500da2-7666-4c7a-9582-5d2c82566c24

각각의 새로운 번역된 단어를 매 시점마다 출력하는데 이때 $h_{Ta}$ 를 입력으로 받고 이전에 디코더 RNN 이 생성했던 단어들의 정보 $y_{t-1}$, 디코더 RNN의 은닉유닛 벡터 $z_{t}$ 를 활용해서 새로운 번역된 단어를 출력하는 것이다. 이 새로운 단어는 단어집에 있는 단어들 중 softmax로 계산된 확률이 제일 높은 하나가 출력되는 것이다. <br/>

이 디코더 RNN 은 이미 다른 데이터로 학습이 완료된 RNN 의 파라미터를 초기 파라미터로 설정할 수 있다. 최적화된 파라미터 재활용하니까 더 빠르다.<br/>

인코더, 디코더 RNN 을 이용한 기계번역의 특징.<br/>
경사하강법을 이용하여 입력층부터 출력층 까지 한꺼번에 종단 학습이 가능하다.<br/>
종단학습이란 모델에 입력을 주면 출력을 한방에주고 학습도 입력부터 출력사이에 어떤 감독이 필요하지 않은것이다. 입력과 출력을 모델에게 주면 알아서 입력과 출력에 알맞는 함수를 만들수, 학습할수 있는 것이다. 
인코더 RNN, 디코더 RNN 은 원본 문장과 타겟 문장을 분산 표현으로 나타낼 수 있다.<br/>
번역 문제를 의미적 공간인 은닉 유닛 공간에 임베딩 시키기 떄문에 이 의미적 공간을 활용할 수 있다는 장점이 있다. 사용하여 학습할 수 있다.<br/>
기존 통계적 기계학습의 방식과 달리 미리 정의된 단어 정렬 방식을 사용하지 않는다. 단어 정렬 방식을 사용하면 파라미터가 굉장히 많아진다.<br/>
개념적으로 이해하기 쉬운 디코딩 방식 사용, 음성 인식과 비슷한 크기의 복잡도.<br/>
통계적 기계학습에 비해 적은 모델 파라미터 갯수를 사용한다. 더 적은 메모리를 사용한다는 의미이다.<br/>

<br/>@
인코더 디코더 RNN은 RNN 이라 문제점이 있다.<br/>
은닉 유닛의 크기가 제한되어있다는 점이다. 입력의 길이 $T_{a}$ 가 길어질 경우, 제한된 크기의 은닉 유닛안에 긴 정보를 모두 인코딩 해야한다. <br/>
번역문제의 경우, 최근에 입력된 정보는 잘 기억하지만 제일 처음 시점에 입력된 정보는 희석이 되어 손실될 수 있기 때문에 이 정보를 번역을 하는데 활용하지 못할 수도 있다는 뜻이다. 이 때 주로 사용하는 은닉 유닛의 크기는 4096 정도이다. <br/>

<br/>@
이를 해결하기 위해서 양방향 RNN 을 활용할수있다.<br/>
길이가 긴 문장이 있을때 한방향으로만 인코딩을 시켜주는게 아니라 역방향으로 인코딩을 시켜줘서 오래전에 입력했던 단어의 경우도 양방향으로 인코딩을 하기때문에 보완을 할 수 있다. <br/>
앞방향 재현 신경망 : 원본 문장의 가장 앞의 단어부터 인코더 RNN 의 입력으로 주어짐.<br/>
뒷방향 재현 신경망 : 원본 문장의 가장 뒤의 단어부터 인코더 RNN 의 입력으로 주어짐.<br/>
인코더 RNN이 주로 양방향 RNN을 활용한다. 이때, 인코더 RNN 의 은닉 유닛이 앞방향 RNN 의 은닉유닛과 뒷방향 RNN의 은닉 유닛을 단순 이어붙인다.<br/>

<br/>@
인코더 RNN 에서 양방향 RNN 에서 계산한 은닉 유닛들을 메모리에 저장한다. <br/>
양방향 RNN 을 사용했을때 입력 문장의 전체 길이만큼 은닉 유닛 개수가 저장된다.<br/>
왜냐하면 앞방향 RNN 을 사용해서 입력문장의 단어의 갯수만큼 생성된 벡터들을 은닉 유닛에 저장한다. <br/>
그리고 뒷방향 RNN 을 사용해서 입력문장의 단어의 갯수만큼 생성된 벡터들을 은닉 유닛에 저장한다. <br/>
그리고 이 둘을 이어붙여준다. 앞방향에서 4000 개 벡터면 뒷방향도 4000개, 그래서 총 8000개 벡터. 하지만 이어붙이면 4000개 벡터가 된다. <br/>

<br/>@
주의 집중 기작 : 특정 한 부분에 집중. 예를들어 나는 학교에 간다 를 번역할 때, I am going to the school. 여기서 going 이라는 걸 출력할때 입력에서 간다 를 모델이 주의 깊게 봐야한다. 이러한 일을 해주는게 주의 집중 기작이다.<br/>
양방향 활용해서 각각의 은닉유닛 벡터를 저장한다고 했는데 인코더 RNN 은닉 유닛 벡터들을 선형조합을 사용 조합을 만들고 디코더 RNN 에 입력으로 넣어서 출력문장의 단어를 생성할때 활용한다.<br/>
예를들어 I를 출력할때 나는 학교에 간다 라는 정보를 선형조합해서 I를 생성할 텐데 제대로된 학습 모델이라면 이 I를 생성할때 나는 이라는 단어에 가장 큰, 학교와 간다에 작은 가중치를 줄것이다. <br/> 
이때 은닉 유닛들에서 나는, 학교에, 간다 에 붙어있는(단어와 가중치의 곱과 합 : 선형조합) 가중치의 합이 1이다.<br/>
인코더 신경망의 각 은닉 유닛은 입력 문장에서 한 개의 단어 정보를 인코딩한다.<br/>
번역기에서 출력되는 단어들은 가중치에 따라 입력으로 주어진 단어들을 선별적으로 고려한다(주의집중)<br/>

<br/>@
어떻게 주의 집중 기작을 활용하는지 자세히 보자.<br/>
인코드 RNN은 각각의 입력문장의 단어들에 대해서 은닉 유닛을 만들어준다. 이 은닉 유닛들은 입력문장의 전체 단어들의 시간과 결부된 정보를 포함하고 있다. <br/>
디코더 RNN은 매 시간 단어를 출력 할 때마다 인코더 RNN 이 계산했던 은닉 유닛벡터들을 가중치를 주면서 고려한다. 이 가중치를 어떻게 계산하냐면 인코더 RNN 에서 은닉유닛 벡터 $h_{t}$ (입력문장 전체의 정보 + 현재 단어의 정보를 포함한다. +1 이다.)와 출력문장의 정보 $s_{t}$ 예를들어 i am going to the 까지 나왔고 school을 출력해야될 차례일때 school 을 출력하기 위해서 입력문장의 특정 단어에 가중치를 줘야한다. 모델이 지금까지 출력했던 단어들의 정보도 같이 고려를 해서 가중치를 준다는 것이다. $z_{t}=W{\cdot}\tanh(V_{z}{\cdot}s_{t-1}+U_{z}{\cdot}h_{t})$  그리고 $z_{t}$ 를 sum 해서 a를 만든다. 그리고 다시 h랑 a를 곱하고 더해서 가중치가 반영된 입력문장 정보를 만든다.<br/>
그리고 이걸로 디코더 RNN 에서 은닉유닛 벡터들을 만들고 번역 문장들을 최종적으로 출력한다.<br/>
92ca75be-c23b-43bd-8134-84c4c8796933

<br/>@
구글 자동 번역기 (GNMT) 2016 11 논문.
RNN 대신 그라디언트 손실을 줄이기 위해 GRU를 사용한다.<br/>
인코더 GRU 8층 (2층 GRU는 역방향) <br/>
디코더 GRU 8층.<br/>

입력문장의 단어를 입력으로 받고 이 단어들을 바탕으로 해서 최종 은닉 유닛 벡터 $h_{Ta}$ 를 생성한다. 그리고 이 은닉 유닛 벡터와 주의 집중 기작을 활용하여 어떤 단어에 초점을 맞춰 가중치를 계산한다. weighted sum 을 해서 새로운 단어를 출력해준다. 출력도 8층 GRU 를 활용한다.  <br/>
a05e63cb-317e-4a06-8e08-a33aab1c11ea

<br/>@
자동번역기 성능측정 : BLEU Bi Lingual Evaluation Understudy 2002년 IBM 사의 SMT 그룹에서 제안함.<br/>
기계번역에서 널리 사용된다.<br/>
BLUE 계산 방식 <br/>
$p_{n}$ 수정된 n gram precision 이다. 일치하는 중복단어는 무시한다.<br/>
이게 뭐냐면, 번역된 문장의 단어중에서 정답 번역문장과 비교했을때 몇개나 일치하느냐 따졌었다. 그런데 정답문장에 the man is sitting. 이라고 하면 번역문장에 the the the the 만 출력해서 높은 점수 precision 1 을 얻을 수 있다. 이런걸 방지하기 위해 중복단어는 무시하는 것이다. 이게 수정된 n gram precision이다. n gram 이라는 것은 무엇이냐. 1gram 부터 4gram 까지 널리사용된다. 1gram은 연속된 한단어까지 일치하는지 안하는지보는것이고, 2gram은 연속된 2단어까지 일치하는지 확인하는 것이다. <br/>
$p_{1}, p_{2}, ..., p_{n}$ 의 기하평균 계산한다. <br/>
Brevity Penalty(BP) : c= 번역된 문장의 길이, r= 정답 문장의 길이.<br/>
긴문장말고 짧게 생성된 번역 문장일수록(정확도가 상대적으로 잘 나오는 케이스) 높은 점수를 얻게 되는 현상을 방지한다.<br/>
$BLUE = BP({\prod\limits_{n=1}^{N}p_{n}})^{\frac{1}{N}}$<br/>
$BP = 1 if c=$ 번역된 문장의 길이 $> r=$ 정답 문장의 길이<br/>\
$BP = \frac{r}{c} if c{\leq}r$<br/>
주로 N=4를 사용한다.<br/>

<br/>@
신경망을 이용한 이미지 번역 : 어떤 이미지가 주어졌을때 그 이미지를 제일 잘 설명할수 있는 문장을 출력해주는 것이다. 구글 번역기와 유사한 문제로 나타낼 수 있다. conditional probability 를 계산 할 수 있는 것이다.<br/>
한 개의 CNN과 RNN 이 이미지 I가 주어졌을 때, 가장 알맞은(확률이 제일 높은) 설명문 Y가 나타날 확률을 모델링 한다.<br/>
$P(y_{1}, y_{2}, ..., y_{T_{b}}|I)$<br/>

<br/>@
인코더 CNN<br/>
입력문장에서 입력 이미지로 바꾸는 방법: 이미지를 여러 등분 $I=(i_{1}, i_{2}, ...i_{a}, ..., i_{A})$ 으로 나눈다. 그러면 각각의 부분 이미지들을 단어처럼 생각할 수 있다. 그래서 이미지들이 순차적으로 입력으로 들어오게된다. 아까는 이 단어들을 RNN 으로 계산했는데 이미지니까 CNN 으로 부분 이미지 $i_{a}$ 를 인코딩 계산 한다. 계산된 벡터 h_{a}를 디코더 RNN 에 입력으로 넣어준다. <br/>
인코딩된 벡터들을 인코더 RNN 의 은닉 유닛 처럼 사용한다.(매 시점 마다 부분 이미지 $i_{a}$가 입력된다.)<br/>
$h_{a}=CNN(i_{a})$<br/>

<br/>@
디코더 RNN<br/>
기계 번역 세팅과 같이, 각 시간 단위마다, RNN 은 $h_{a}$ (입력 이미지 정보), $y_{t-1}$ (이전 시점 단계에서 생성된 단어), $z_{t-1}$ (디코더 RNN 은닉 유닛 정보) 를 기반으로 다음 단어 $y_{t}$를 예측한다.<br/>

$z_{t}=\phi_{\theta'}(h_{a}{\cdot}y_{t-1}, z_{t-1})$<br/>
$p(y_{t}|y_{until\;t)}, X) = g(z_{t-1})$<br/>
 
<br/>@
신경망을 이용한 이미지 번역을 자세히 보자.<br/>
입력이미지가 있으면 이걸 여러 등분으로 나눈다. 각각의 등분이미지를 CNN을 사용해 인코딩해준다. 인코딩된 벡터들은 작은 이미지들을 설명해주는 벡터로 볼수있다. <br/>
이전에 봤던건 시계열 데이터 문장 $X = (x_{1}, x_{2}, ..., x_{n})$ 을 RNN을 사용해서 각각의 문장과 단어를 설명해주는 RNN의 은닉 유닛 $h_{Ta}$을 계산했다. 그런데 지금의 경우에는 이 $h_{Ta}$ 를 RNN으로 계산한게 아니라 CNN으로 계산한 것이다. 이 CNN 을 활용해 계산한 벡터 $h_{Ta}$ 가 RNN으로 만든 $h_{Ta}$ 처럼 작동 할 수 있다는 것이다. 그래서 방금 말한 거처럼 주의집중기작활용해서 설명문장을 출력 할수 있는 것이다. <br/>
145d91b8-b195-4139-b2e9-a02b30af84d6
     
   </BODY>
</HTML>
